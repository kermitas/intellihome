<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>16.10. Match</title><link rel="stylesheet" href="docbook-xsl.css" type="text/css" /><meta name="generator" content="DocBook XSL Stylesheets V1.75.2" /><link rel="home" href="index.html" title="The Neo4j Manual v1.8.M04" /><link rel="up" href="cypher-query-lang.html" title="Chapter 16. Cypher Query Language" /><link rel="prev" href="query-start.html" title="16.9. Start" /><link rel="next" href="query-where.html" title="16.11. Where" /><link rel="preface" href="preface.html" title="Preface" /><link rel="part" href="introduction.html" title="Part I. Introduction" /><link rel="chapter" href="introduction-highlights.html" title="Chapter 1. Neo4j Highlights" /><link rel="chapter" href="graphdb-concepts.html" title="Chapter 2. Graph Database Concepts" /><link rel="chapter" href="graphdb-neo4j.html" title="Chapter 3. The Neo4j Graph Database" /><link rel="part" href="tutorials.html" title="Part II. Tutorials" /><link rel="chapter" href="tutorials-java-embedded.html" title="Chapter 4. Using Neo4j embedded in Java applications" /><link rel="chapter" href="cypher-cookbook.html" title="Chapter 5. Cypher Cookbook" /><link rel="chapter" href="tutorials-rest.html" title="Chapter 6. Neo4j Remote Client Libraries" /><link rel="chapter" href="server-extending.html" title="Chapter 7. Extending the Neo4j Server" /><link rel="chapter" href="tutorial-traversal.html" title="Chapter 8. The Traversal Framework" /><link rel="chapter" href="domain-modeling-gallery.html" title="Chapter 9. Domain Modeling Gallery" /><link rel="chapter" href="languages.html" title="Chapter 10. Languages" /><link rel="chapter" href="tutorials-python-embedded.html" title="Chapter 11. Using Neo4j embedded in Python applications" /><link rel="part" href="reference-documentation.html" title="Part III. Reference" /><link rel="chapter" href="capabilities.html" title="Chapter 12. Capabilities" /><link rel="chapter" href="transactions.html" title="Chapter 13. Transaction Management" /><link rel="chapter" href="import.html" title="Chapter 14. Data Import" /><link rel="chapter" href="indexing.html" title="Chapter 15. Indexing" /><link rel="chapter" href="cypher-query-lang.html" title="Chapter 16. Cypher Query Language" /><link rel="chapter" href="graph-algo.html" title="Chapter 17. Graph Algorithms" /><link rel="chapter" href="server.html" title="Chapter 18. Neo4j Server" /><link rel="chapter" href="rest-api.html" title="Chapter 19. REST API" /><link rel="chapter" href="python-embedded.html" title="Chapter 20. Python embedded bindings" /><link rel="part" href="operations.html" title="Part IV. Operations" /><link rel="chapter" href="deployment.html" title="Chapter 21. Installation &amp; Deployment" /><link rel="chapter" href="embedded-configuration.html" title="Chapter 22. Configuration &amp; Performance" /><link rel="chapter" href="ha.html" title="Chapter 23. High Availability" /><link rel="chapter" href="operations-backup.html" title="Chapter 24. Backup" /><link rel="chapter" href="operations-security.html" title="Chapter 25. Security" /><link rel="chapter" href="operations-monitoring.html" title="Chapter 26. Monitoring" /><link rel="part" href="tools.html" title="Part V. Tools" /><link rel="chapter" href="tools-webadmin.html" title="Chapter 27. Web Administration" /><link rel="chapter" href="shell.html" title="Chapter 28. Neo4j Shell" /><link rel="part" href="community.html" title="Part VI. Community" /><link rel="chapter" href="community-support.html" title="Chapter 29. Community Support" /><link rel="chapter" href="community-contributing.html" title="Chapter 30. Contributing to Neo4j" /><link rel="appendix" href="manpages.html" title="Appendix A. Manpages" /><link rel="refentry" href="re01.html" title="neo4j" /><link rel="refentry" href="re02.html" title="neo4j-shell" /><link rel="refentry" href="re03.html" title="neo4j-backup" /><link rel="refentry" href="re04.html" title="neo4j-coordinator" /><link rel="refentry" href="re05.html" title="neo4j-coordinator-shell" /><link rel="appendix" href="questions.html" title="Appendix B. Questions &amp; Answers" /><link rel="subsection" href="query-match.html#match-introduction" title="16.10.1. Introduction" /><link rel="subsection" href="query-match.html#match-related-nodes" title="16.10.2. Related nodes" /><link rel="subsection" href="query-match.html#match-outgoing-relationships" title="16.10.3. Outgoing relationships" /><link rel="subsection" href="query-match.html#match-directed-relationships-and-identifier" title="16.10.4. Directed relationships and identifier" /><link rel="subsection" href="query-match.html#match-match-by-relationship-type" title="16.10.5. Match by relationship type" /><link rel="subsection" href="query-match.html#match-match-by-multiple-relationship-types" title="16.10.6. Match by multiple relationship types" /><link rel="subsection" href="query-match.html#match-match-by-relationship-type-and-use-an-identifier" title="16.10.7. Match by relationship type and use an identifier" /><link rel="subsection" href="query-match.html#match-relationship-types-with-uncommon-characters" title="16.10.8. Relationship types with uncommon characters" /><link rel="subsection" href="query-match.html#match-multiple-relationships" title="16.10.9. Multiple relationships" /><link rel="subsection" href="query-match.html#match-variable-length-relationships" title="16.10.10. Variable length relationships" /><link rel="subsection" href="query-match.html#match-relationship-identifier-in-variable-length-relationships" title="16.10.11. Relationship identifier in variable length relationships" /><link rel="subsection" href="query-match.html#match-zero-length-paths" title="16.10.12. Zero length paths" /><link rel="subsection" href="query-match.html#match-optional-relationship" title="16.10.13. Optional relationship" /><link rel="subsection" href="query-match.html#match-optional-typed-and-named-relationship" title="16.10.14. Optional typed and named relationship" /><link rel="subsection" href="query-match.html#match-properties-on-optional-elements" title="16.10.15. Properties on optional elements" /><link rel="subsection" href="query-match.html#match-complex-matching" title="16.10.16. Complex matching" /><link rel="subsection" href="query-match.html#match-shortest-path" title="16.10.17. Shortest path" /><link rel="subsection" href="query-match.html#match-all-shortest-paths" title="16.10.18. All shortest paths" /><link rel="subsection" href="query-match.html#match-named-path" title="16.10.19. Named path" /><link rel="subsection" href="query-match.html#match-matching-on-a-bound-relationship" title="16.10.20. Matching on a bound relationship" /><link rel="copyright" href="ln-id464096.html" title="License: Creative Commons 3.0" />


<!-- favicon -->

<link rel="shortcut icon" href="http://neo4j.org/favicon.ico" type="image/vnd.microsoft.icon" />
<link rel="icon" href="http://neo4j.org/favicon.ico" type="image/x-icon" />

<!-- style -->

<link href="css/shCore.css" rel="stylesheet" type="text/css" />
<link href="css/shCoreEclipse.css" rel="stylesheet" type="text/css" />
<link href="css/shThemeEclipse.css" rel="stylesheet" type="text/css" />
<link href="css/neo.css" rel="stylesheet" type="text/css" />

<!-- Syntax Highlighter -->

<script type="text/javascript" src="js/shCore.js"></script>
<script type="text/javascript" src="js/shBrushJava.js"></script>
<script type="text/javascript" src="js/shBrushJScript.js"></script>
<script type="text/javascript" src="js/shBrushBash.js"></script>
<script type="text/javascript" src="js/shBrushPlain.js"></script>
<script type="text/javascript" src="js/shBrushXml.js"></script>
<script type="text/javascript" src="js/shBrushGroovy.js"></script>
<script type="text/javascript" src="js/shBrushCypher.js"></script>
<script type="text/javascript" src="js/shBrushScala.js"></script>
<script type="text/javascript" src="js/shBrushSql.js"></script>
<script type="text/javascript" src="js/shBrushPython.js"></script>

<!-- activate when needed
<script type="text/javascript" src="js/shBrushRuby.js"></script>
<script type="text/javascript" src="js/shBrushCSharp.js"></script>
-->
 
<script type="text/javascript">
  SyntaxHighlighter.defaults['tab-size'] = 4;
  SyntaxHighlighter.defaults['gutter'] = false;
  SyntaxHighlighter.defaults['toolbar'] = false;
  SyntaxHighlighter.all()
</script>

<!-- JQuery -->

<script type="text/javascript" src="js/jquery-1.6.4.min.js"></script>

<!-- Replace SVG for browsers that lack support. -->
<script type="text/javascript" src="js/svgreplacer.js"></script>

<!-- Image Scaler -->

<script type="text/javascript" src="js/imagescaler.js"></script>

<!-- Table Styler -->

<script type="text/javascript" src="js/tablestyler.js"></script>

<!-- Version -->

<script type="text/javascript" src="js/version.js"></script>

<!-- Offline Sidebar -->

<script type="text/javascript" src="js/sidebar.js"></script>


<div xmlns="" class="breadcrumbs"><span class="breadcrumb-link"><a href="index.html">The Neo4j Manual</a></span> &gt; <span class="breadcrumb-link"><a href="reference-documentation.html">Reference</a></span> &gt; <span class="breadcrumb-link"><a href="cypher-query-lang.html">Cypher Query Language</a></span> &gt; <span class="breadcrumb-node">Match</span></div></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><td width="20%" align="left"><a accesskey="p" href="query-start.html">Prev</a> </td><th width="60%" align="center"> </th><td width="20%" align="right"> <a accesskey="n" href="query-where.html">Next</a></td></tr></table><hr /></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="query-match"></a>16.10. Match</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="query-match.html#match-introduction">16.10.1. Introduction</a></span></dt><dt><span class="section"><a href="query-match.html#match-related-nodes">16.10.2. Related nodes</a></span></dt><dt><span class="section"><a href="query-match.html#match-outgoing-relationships">16.10.3. Outgoing relationships</a></span></dt><dt><span class="section"><a href="query-match.html#match-directed-relationships-and-identifier">16.10.4. Directed relationships and identifier</a></span></dt><dt><span class="section"><a href="query-match.html#match-match-by-relationship-type">16.10.5. Match by relationship type</a></span></dt><dt><span class="section"><a href="query-match.html#match-match-by-multiple-relationship-types">16.10.6. Match by multiple relationship types</a></span></dt><dt><span class="section"><a href="query-match.html#match-match-by-relationship-type-and-use-an-identifier">16.10.7. Match by relationship type and use an identifier</a></span></dt><dt><span class="section"><a href="query-match.html#match-relationship-types-with-uncommon-characters">16.10.8. Relationship types with uncommon characters</a></span></dt><dt><span class="section"><a href="query-match.html#match-multiple-relationships">16.10.9. Multiple relationships</a></span></dt><dt><span class="section"><a href="query-match.html#match-variable-length-relationships">16.10.10. Variable length relationships</a></span></dt><dt><span class="section"><a href="query-match.html#match-relationship-identifier-in-variable-length-relationships">16.10.11. Relationship identifier in variable length relationships</a></span></dt><dt><span class="section"><a href="query-match.html#match-zero-length-paths">16.10.12. Zero length paths</a></span></dt><dt><span class="section"><a href="query-match.html#match-optional-relationship">16.10.13. Optional relationship</a></span></dt><dt><span class="section"><a href="query-match.html#match-optional-typed-and-named-relationship">16.10.14. Optional typed and named relationship</a></span></dt><dt><span class="section"><a href="query-match.html#match-properties-on-optional-elements">16.10.15. Properties on optional elements</a></span></dt><dt><span class="section"><a href="query-match.html#match-complex-matching">16.10.16. Complex matching</a></span></dt><dt><span class="section"><a href="query-match.html#match-shortest-path">16.10.17. Shortest path</a></span></dt><dt><span class="section"><a href="query-match.html#match-all-shortest-paths">16.10.18. All shortest paths</a></span></dt><dt><span class="section"><a href="query-match.html#match-named-path">16.10.19. Named path</a></span></dt><dt><span class="section"><a href="query-match.html#match-matching-on-a-bound-relationship">16.10.20. Matching on a bound relationship</a></span></dt></dl></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="match-introduction"></a>16.10.1. Introduction</h3></div></div></div><p>Pattern matching is one of the pillars of Cypher. The pattern is used to describe the shape of the data that we are
looking for. Cypher will then try to find patterns in the graph — these are called matching subgraphs.</p><p>Patterns have bound points, or start points. They are the parts of the pattern that are already “bound” to a set of
graph nodes or relationships. All parts of the pattern must be directly or indirectly connected to a start point — a pattern
where parts of the pattern are not reachable from any start point will be rejected.</p><p>The optional relationship is a way to describe parts of the pattern that can evaluate to <code class="literal">null</code> if it can not be
matched to the graph. It’s the equivalent of SQL outer join — if Cypher finds one or more matches, they will be
returned. If no matches are found, Cypher will return a <code class="literal">null</code>. Only relationships can be marked as optional, and it’s
done with a question mark.</p><p>Optional relationships of the pattern are used to answer queries like this:</p><pre class="programlisting brush: cypher">START me=node(1)
MATCH me--&gt;friend-[?:parent_of]-&gt;children
RETURN friend, children</pre><p>The query above says “give me all my friends, and their children, if they have any.”</p><p>Optionality is transitive — if a part of the pattern can only be reached from a bound point through an optional relationship,
that part is also optional. In the pattern above, the only bound point in the pattern is <code class="literal">me</code>. Since the relationship
between <code class="literal">friend</code> and <code class="literal">children</code> is optional, <code class="literal">children</code> is an optional part of the graph.</p><p>Also, named paths that contain optional parts are also optional — if any part of the path is
<code class="literal">null</code>, the whole path is <code class="literal">null</code>.</p><p>In these examples, <code class="literal">b</code> and <code class="literal">p</code> are all optional and can contain <code class="literal">null</code>:</p><pre class="programlisting brush: cypher">START a=node(1)
MATCH p = a-[?]-&gt;b
RETURN b</pre><pre class="programlisting brush: cypher">START a=node(1)
MATCH p = a-[?*]-&gt;b
RETURN b</pre><pre class="programlisting brush: cypher">START a=node(1)
MATCH p = a-[?]-&gt;x--&gt;b
RETURN b</pre><pre class="programlisting brush: cypher">START a=node(1), x=node(2)
MATCH p = shortestPath( a-[?*]-&gt;x )
RETURN p</pre><p>As a simple example, let’s take the following query, executed on the graph pictured below.</p><p><span class="emphasis"><em>Query</em></span></p><pre class="programlisting brush: cypher">START me=node(1)
MATCH me--&gt;friend-[?:parent_of]-&gt;children
RETURN friend, children</pre><p>This returns the a <code class="literal">friend</code> node, and no <code class="literal">children</code>, since there are no such relatoinships in the graph.</p><div class="queryresult table"><a id="id531082"></a><p class="title"><b>Result</b></p><div class="queryresult table-contents"><table summary="Result" cellspacing="0" cellpadding="0" border="1"><colgroup><col /><col /></colgroup><thead><tr><th align="left" valign="top">friend</th><th align="left" valign="top">children</th></tr></thead><tfoot><tr><th colspan="2" align="left" valign="top">1 row
</th></tr><tr><th colspan="2" align="left" valign="top">1 ms</th></tr></tfoot><tbody><tr><td align="left" valign="top"><p><code class="literal">Node[3]{name:"Anders"}</code></p></td><td align="left" valign="top"><p><code class="literal">&lt;null&gt;</code></p></td></tr></tbody></table></div></div><br class="queryresult table-break" /><p>For the examples given in the sections below, the follwoing graph is the base:</p><p><span class="emphasis"><em>Graph</em></span></p><div class="informalfigure"><a class="ulink" href="images/cypher-match-graph.svg" target="_top">
<span class="inlinemediaobject"><img src="images/cypher-match-graph.svg" alt="cypher-match-graph.svg" /></span>
</a></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="match-related-nodes"></a>16.10.2. Related nodes</h3></div></div></div><p>The symbol <code class="literal">--</code> means <span class="emphasis"><em>related to,</em></span> without regard to type or direction.</p><p><span class="emphasis"><em>Query</em></span></p><pre class="programlisting brush: cypher">START n=node(3)
MATCH (n)--(x)
RETURN x</pre><p>All nodes related to A (Anders) are returned.</p><div class="queryresult table"><a id="id531272"></a><p class="title"><b>Result</b></p><div class="queryresult table-contents"><table summary="Result" cellspacing="0" cellpadding="0" border="1"><colgroup><col /></colgroup><thead><tr><th align="left" valign="top">x</th></tr></thead><tfoot><tr><th align="left" valign="top">3 rows
</th></tr><tr><th align="left" valign="top">0 ms</th></tr></tfoot><tbody><tr><td align="left" valign="top"><p><code class="literal">Node[4]{name:"Bossman"}</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">Node[1]{name:"David"}</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">Node[5]{name:"Cesar"}</code></p></td></tr></tbody></table></div></div><br class="queryresult table-break" /></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="match-outgoing-relationships"></a>16.10.3. Outgoing relationships</h3></div></div></div><p>When the direction of a relationship is interesting, it is shown by using <code class="literal">--&gt;</code> or <code class="literal">&lt;--</code>, like this:</p><p><span class="emphasis"><em>Query</em></span></p><pre class="programlisting brush: cypher">START n=node(3)
MATCH (n)--&gt;(x)
RETURN x</pre><p>All nodes that A has outgoing relationships to.</p><div class="queryresult table"><a id="id531432"></a><p class="title"><b>Result</b></p><div class="queryresult table-contents"><table summary="Result" cellspacing="0" cellpadding="0" border="1"><colgroup><col /></colgroup><thead><tr><th align="left" valign="top">x</th></tr></thead><tfoot><tr><th align="left" valign="top">2 rows
</th></tr><tr><th align="left" valign="top">0 ms</th></tr></tfoot><tbody><tr><td align="left" valign="top"><p><code class="literal">Node[4]{name:"Bossman"}</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">Node[5]{name:"Cesar"}</code></p></td></tr></tbody></table></div></div><br class="queryresult table-break" /></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="match-directed-relationships-and-identifier"></a>16.10.4. Directed relationships and identifier</h3></div></div></div><p>If an identifier is needed, either for filtering on properties of the relationship, or to return the relationship, this is how you introduce the identifier.</p><p><span class="emphasis"><em>Query</em></span></p><pre class="programlisting brush: cypher">START n=node(3)
MATCH (n)-[r]-&gt;()
RETURN r</pre><p>All outgoing relationships from node A.</p><div class="queryresult table"><a id="id531569"></a><p class="title"><b>Result</b></p><div class="queryresult table-contents"><table summary="Result" cellspacing="0" cellpadding="0" border="1"><colgroup><col /></colgroup><thead><tr><th align="left" valign="top">r</th></tr></thead><tfoot><tr><th align="left" valign="top">2 rows
</th></tr><tr><th align="left" valign="top">0 ms</th></tr></tfoot><tbody><tr><td align="left" valign="top"><p><code class="literal">:KNOWS[0] {}</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">:BLOCKS[1] {}</code></p></td></tr></tbody></table></div></div><br class="queryresult table-break" /></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="match-match-by-relationship-type"></a>16.10.5. Match by relationship type</h3></div></div></div><p>When you know the relationship type you want to match on, you can specify it by using a colon.</p><p><span class="emphasis"><em>Query</em></span></p><pre class="programlisting brush: cypher">START n=node(3)
MATCH (n)-[:BLOCKS]-&gt;(x)
RETURN x</pre><p>All nodes that are BLOCKed by A.</p><div class="queryresult table"><a id="id531705"></a><p class="title"><b>Result</b></p><div class="queryresult table-contents"><table summary="Result" cellspacing="0" cellpadding="0" border="1"><colgroup><col /></colgroup><thead><tr><th align="left" valign="top">x</th></tr></thead><tfoot><tr><th align="left" valign="top">1 row
</th></tr><tr><th align="left" valign="top">0 ms</th></tr></tfoot><tbody><tr><td align="left" valign="top"><p><code class="literal">Node[5]{name:"Cesar"}</code></p></td></tr></tbody></table></div></div><br class="queryresult table-break" /></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="match-match-by-multiple-relationship-types"></a>16.10.6. Match by multiple relationship types</h3></div></div></div><p>If multiple types are acceptable, you can specify this by chaining them with the pipe symbol <code class="literal">|</code>.</p><p><span class="emphasis"><em>Query</em></span></p><pre class="programlisting brush: cypher">START n=node(3)
MATCH (n)-[:BLOCKS|KNOWS]-&gt;(x)
RETURN x</pre><p>All nodes with a <code class="literal">BLOCK</code> or <code class="literal">KNOWS</code> relationship to A.</p><div class="queryresult table"><a id="id531847"></a><p class="title"><b>Result</b></p><div class="queryresult table-contents"><table summary="Result" cellspacing="0" cellpadding="0" border="1"><colgroup><col /></colgroup><thead><tr><th align="left" valign="top">x</th></tr></thead><tfoot><tr><th align="left" valign="top">2 rows
</th></tr><tr><th align="left" valign="top">0 ms</th></tr></tfoot><tbody><tr><td align="left" valign="top"><p><code class="literal">Node[5]{name:"Cesar"}</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">Node[4]{name:"Bossman"}</code></p></td></tr></tbody></table></div></div><br class="queryresult table-break" /></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="match-match-by-relationship-type-and-use-an-identifier"></a>16.10.7. Match by relationship type and use an identifier</h3></div></div></div><p>If you both want to introduce an identifier to hold the relationship, and specify the relationship type you want, just add them both, like this.</p><p><span class="emphasis"><em>Query</em></span></p><pre class="programlisting brush: cypher">START n=node(3)
MATCH (n)-[r:BLOCKS]-&gt;()
RETURN r</pre><p>All <code class="literal">BLOCKS</code> relationship going out from A.</p><div class="queryresult table"><a id="id531989"></a><p class="title"><b>Result</b></p><div class="queryresult table-contents"><table summary="Result" cellspacing="0" cellpadding="0" border="1"><colgroup><col /></colgroup><thead><tr><th align="left" valign="top">r</th></tr></thead><tfoot><tr><th align="left" valign="top">1 row
</th></tr><tr><th align="left" valign="top">0 ms</th></tr></tfoot><tbody><tr><td align="left" valign="top"><p><code class="literal">:BLOCKS[1] {}</code></p></td></tr></tbody></table></div></div><br class="queryresult table-break" /></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="match-relationship-types-with-uncommon-characters"></a>16.10.8. Relationship types with uncommon characters</h3></div></div></div><p>Sometime your database will have types with non-letter characters, or with spaces in them. Use ` to escape these.</p><p><span class="emphasis"><em>Query</em></span></p><pre class="programlisting brush: cypher">START n=node(3)
MATCH (n)-[r:`TYPE
WITH SPACE IN IT`]-&gt;()
RETURN r</pre><p>This returns a relationship of a type with spaces in it.</p><div class="queryresult table"><a id="id532113"></a><p class="title"><b>Result</b></p><div class="queryresult table-contents"><table summary="Result" cellspacing="0" cellpadding="0" border="1"><colgroup><col /></colgroup><thead><tr><th align="left" valign="top">r</th></tr></thead><tfoot><tr><th align="left" valign="top">1 row
</th></tr><tr><th align="left" valign="top">0 ms</th></tr></tfoot><tbody><tr><td align="left" valign="top"><p><code class="literal">:TYPE WITH SPACE IN IT[6] {}</code></p></td></tr></tbody></table></div></div><br class="queryresult table-break" /></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="match-multiple-relationships"></a>16.10.9. Multiple relationships</h3></div></div></div><p>Relationships can be expressed by using multiple statements in the form of <code class="literal">()--()</code>, or they can be strung together, like this:</p><p><span class="emphasis"><em>Query</em></span></p><pre class="programlisting brush: cypher">START a=node(3)
MATCH (a)-[:KNOWS]-&gt;(b)-[:KNOWS]-&gt;(c)
RETURN a,b,c</pre><p>The three nodes in the path are returned.</p><div class="queryresult table"><a id="id532244"></a><p class="title"><b>Result</b></p><div class="queryresult table-contents"><table summary="Result" cellspacing="0" cellpadding="0" border="1"><colgroup><col /><col /><col /></colgroup><thead><tr><th align="left" valign="top">a</th><th align="left" valign="top">b</th><th align="left" valign="top">c</th></tr></thead><tfoot><tr><th colspan="3" align="left" valign="top">1 row
</th></tr><tr><th colspan="3" align="left" valign="top">0 ms</th></tr></tfoot><tbody><tr><td align="left" valign="top"><p><code class="literal">Node[3]{name:"Anders"}</code></p></td><td align="left" valign="top"><p><code class="literal">Node[4]{name:"Bossman"}</code></p></td><td align="left" valign="top"><p><code class="literal">Node[2]{name:"Emil"}</code></p></td></tr></tbody></table></div></div><br class="queryresult table-break" /></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="match-variable-length-relationships"></a>16.10.10. Variable length relationships</h3></div></div></div><p>Nodes that are a variable number of relationship→node hops away can be found using <code class="literal">-[:TYPE*minHops..maxHops]-&gt;</code>.</p><p><span class="emphasis"><em>Query</em></span></p><pre class="programlisting brush: cypher">START a=node(3), x=node(2, 4)
MATCH a-[:KNOWS*1..3]-&gt;x
RETURN a,x</pre><p>Returns the start and end point, if there is a path between 1 and 3 relationships away.</p><div class="queryresult table"><a id="id532416"></a><p class="title"><b>Result</b></p><div class="queryresult table-contents"><table summary="Result" cellspacing="0" cellpadding="0" border="1"><colgroup><col /><col /></colgroup><thead><tr><th align="left" valign="top">a</th><th align="left" valign="top">x</th></tr></thead><tfoot><tr><th colspan="2" align="left" valign="top">2 rows
</th></tr><tr><th colspan="2" align="left" valign="top">0 ms</th></tr></tfoot><tbody><tr><td align="left" valign="top"><p><code class="literal">Node[3]{name:"Anders"}</code></p></td><td align="left" valign="top"><p><code class="literal">Node[2]{name:"Emil"}</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">Node[3]{name:"Anders"}</code></p></td><td align="left" valign="top"><p><code class="literal">Node[4]{name:"Bossman"}</code></p></td></tr></tbody></table></div></div><br class="queryresult table-break" /></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="match-relationship-identifier-in-variable-length-relationships"></a>16.10.11. Relationship identifier in variable length relationships</h3></div></div></div><p>When the connection between two nodes is of variable length, a relationship identifier becomes an iterable of relationships.</p><p><span class="emphasis"><em>Query</em></span></p><pre class="programlisting brush: cypher">START a=node(3), x=node(2, 4)
MATCH a-[r:KNOWS*1..3]-&gt;x
RETURN r</pre><p>Returns the relationships, if there is a path between 1 and 3 relationships away.</p><div class="queryresult table"><a id="id532586"></a><p class="title"><b>Result</b></p><div class="queryresult table-contents"><table summary="Result" cellspacing="0" cellpadding="0" border="1"><colgroup><col /></colgroup><thead><tr><th align="left" valign="top">r</th></tr></thead><tfoot><tr><th align="left" valign="top">2 rows
</th></tr><tr><th align="left" valign="top">0 ms</th></tr></tfoot><tbody><tr><td align="left" valign="top"><p><code class="literal">[:KNOWS[0] {},:KNOWS[3] {}]</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">[:KNOWS[0] {}]</code></p></td></tr></tbody></table></div></div><br class="queryresult table-break" /></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="match-zero-length-paths"></a>16.10.12. Zero length paths</h3></div></div></div><p>When using variable length paths that have the lower bound zero, it means that two identifiers can point to the same node. If the distance between two nodes is zero, they are, by definition, the same node.</p><p><span class="emphasis"><em>Query</em></span></p><pre class="programlisting brush: cypher">START a=node(3)
MATCH p1=a-[:KNOWS*0..1]-&gt;b, p2=b-[:BLOCKS*0..1]-&gt;c
RETURN a,b,c, length(p1), length(p2)</pre><p>This query will return four paths, some of them with length zero.</p><div class="queryresult table"><a id="id532725"></a><p class="title"><b>Result</b></p><div class="queryresult table-contents"><table summary="Result" cellspacing="0" cellpadding="0" border="1"><colgroup><col /><col /><col /><col /><col /></colgroup><thead><tr><th align="left" valign="top">a</th><th align="left" valign="top">b</th><th align="left" valign="top">c</th><th align="left" valign="top">length(p1)</th><th align="left" valign="top">length(p2)</th></tr></thead><tfoot><tr><th colspan="5" align="left" valign="top">4 rows
</th></tr><tr><th colspan="5" align="left" valign="top">0 ms</th></tr></tfoot><tbody><tr><td align="left" valign="top"><p><code class="literal">Node[3]{name:"Anders"}</code></p></td><td align="left" valign="top"><p><code class="literal">Node[3]{name:"Anders"}</code></p></td><td align="left" valign="top"><p><code class="literal">Node[3]{name:"Anders"}</code></p></td><td align="left" valign="top"><p><code class="literal">0</code></p></td><td align="left" valign="top"><p><code class="literal">0</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">Node[3]{name:"Anders"}</code></p></td><td align="left" valign="top"><p><code class="literal">Node[3]{name:"Anders"}</code></p></td><td align="left" valign="top"><p><code class="literal">Node[5]{name:"Cesar"}</code></p></td><td align="left" valign="top"><p><code class="literal">0</code></p></td><td align="left" valign="top"><p><code class="literal">1</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">Node[3]{name:"Anders"}</code></p></td><td align="left" valign="top"><p><code class="literal">Node[4]{name:"Bossman"}</code></p></td><td align="left" valign="top"><p><code class="literal">Node[4]{name:"Bossman"}</code></p></td><td align="left" valign="top"><p><code class="literal">1</code></p></td><td align="left" valign="top"><p><code class="literal">0</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">Node[3]{name:"Anders"}</code></p></td><td align="left" valign="top"><p><code class="literal">Node[4]{name:"Bossman"}</code></p></td><td align="left" valign="top"><p><code class="literal">Node[1]{name:"David"}</code></p></td><td align="left" valign="top"><p><code class="literal">1</code></p></td><td align="left" valign="top"><p><code class="literal">1</code></p></td></tr></tbody></table></div></div><br class="queryresult table-break" /></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="match-optional-relationship"></a>16.10.13. Optional relationship</h3></div></div></div><p>If a relationship is optional, it can be marked with a question mark. This is similar to how a SQL outer join works. If the relationship is there, it is returned. If it’s not, <code class="literal">null</code> is returned in it’s place. Remember that anything hanging off an optional relationship, is in turn optional, unless it is connected with a bound node through some other path.</p><p><span class="emphasis"><em>Query</em></span></p><pre class="programlisting brush: cypher">START a=node(2)
MATCH a-[?]-&gt;x
RETURN a,x</pre><p>A node, and <code class="literal">null</code>, since the node has no outgoing relationships.</p><div class="queryresult table"><a id="id533118"></a><p class="title"><b>Result</b></p><div class="queryresult table-contents"><table summary="Result" cellspacing="0" cellpadding="0" border="1"><colgroup><col /><col /></colgroup><thead><tr><th align="left" valign="top">a</th><th align="left" valign="top">x</th></tr></thead><tfoot><tr><th colspan="2" align="left" valign="top">1 row
</th></tr><tr><th colspan="2" align="left" valign="top">0 ms</th></tr></tfoot><tbody><tr><td align="left" valign="top"><p><code class="literal">Node[2]{name:"Emil"}</code></p></td><td align="left" valign="top"><p><code class="literal">&lt;null&gt;</code></p></td></tr></tbody></table></div></div><br class="queryresult table-break" /></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="match-optional-typed-and-named-relationship"></a>16.10.14. Optional typed and named relationship</h3></div></div></div><p>Just as with a normal relationship, you can decide which identifier it goes into, and what relationship type you need.</p><p><span class="emphasis"><em>Query</em></span></p><pre class="programlisting brush: cypher">START a=node(3)
MATCH a-[r?:LOVES]-&gt;()
RETURN a,r</pre><p>This returns a node, and <code class="literal">null</code>, since the node has no outgoing <code class="literal">LOVES</code> relationships.</p><div class="queryresult table"><a id="id533275"></a><p class="title"><b>Result</b></p><div class="queryresult table-contents"><table summary="Result" cellspacing="0" cellpadding="0" border="1"><colgroup><col /><col /></colgroup><thead><tr><th align="left" valign="top">a</th><th align="left" valign="top">r</th></tr></thead><tfoot><tr><th colspan="2" align="left" valign="top">1 row
</th></tr><tr><th colspan="2" align="left" valign="top">0 ms</th></tr></tfoot><tbody><tr><td align="left" valign="top"><p><code class="literal">Node[3]{name:"Anders"}</code></p></td><td align="left" valign="top"><p><code class="literal">&lt;null&gt;</code></p></td></tr></tbody></table></div></div><br class="queryresult table-break" /></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="match-properties-on-optional-elements"></a>16.10.15. Properties on optional elements</h3></div></div></div><p>Returning a property from an optional element that is <code class="literal">null</code> will also return <code class="literal">null</code>.</p><p><span class="emphasis"><em>Query</em></span></p><pre class="programlisting brush: cypher">START a=node(2)
MATCH a-[?]-&gt;x
RETURN x, x.name</pre><p>This returns the element x (<code class="literal">null</code> in this query), and <code class="literal">null</code> as it’s name.</p><div class="queryresult table"><a id="id533442"></a><p class="title"><b>Result</b></p><div class="queryresult table-contents"><table summary="Result" cellspacing="0" cellpadding="0" border="1"><colgroup><col /><col /></colgroup><thead><tr><th align="left" valign="top">x</th><th align="left" valign="top">x.name</th></tr></thead><tfoot><tr><th colspan="2" align="left" valign="top">1 row
</th></tr><tr><th colspan="2" align="left" valign="top">0 ms</th></tr></tfoot><tbody><tr><td align="left" valign="top"><p><code class="literal">&lt;null&gt;</code></p></td><td align="left" valign="top"><p><code class="literal">&lt;null&gt;</code></p></td></tr></tbody></table></div></div><br class="queryresult table-break" /></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="match-complex-matching"></a>16.10.16. Complex matching</h3></div></div></div><p>Using Cypher, you can also express more complex patterns to match on, like a diamond shape pattern.</p><p><span class="emphasis"><em>Query</em></span></p><pre class="programlisting brush: cypher">START a=node(3)
MATCH (a)-[:KNOWS]-&gt;(b)-[:KNOWS]-&gt;(c), (a)-[:BLOCKS]-(d)-[:KNOWS]-(c)
RETURN a,b,c,d</pre><p>This returns the four nodes in the paths.</p><div class="queryresult table"><a id="id533587"></a><p class="title"><b>Result</b></p><div class="queryresult table-contents"><table summary="Result" cellspacing="0" cellpadding="0" border="1"><colgroup><col /><col /><col /><col /></colgroup><thead><tr><th align="left" valign="top">a</th><th align="left" valign="top">b</th><th align="left" valign="top">c</th><th align="left" valign="top">d</th></tr></thead><tfoot><tr><th colspan="4" align="left" valign="top">1 row
</th></tr><tr><th colspan="4" align="left" valign="top">0 ms</th></tr></tfoot><tbody><tr><td align="left" valign="top"><p><code class="literal">Node[3]{name:"Anders"}</code></p></td><td align="left" valign="top"><p><code class="literal">Node[4]{name:"Bossman"}</code></p></td><td align="left" valign="top"><p><code class="literal">Node[2]{name:"Emil"}</code></p></td><td align="left" valign="top"><p><code class="literal">Node[5]{name:"Cesar"}</code></p></td></tr></tbody></table></div></div><br class="queryresult table-break" /></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="match-shortest-path"></a>16.10.17. Shortest path</h3></div></div></div><p>Finding a single shortest path between two nodes is as easy as using the <code class="literal">shortestPath</code> function, like this:</p><p><span class="emphasis"><em>Query</em></span></p><pre class="programlisting brush: cypher">START d=node(1), e=node(2)
MATCH p = shortestPath( d-[*..15]-&gt;e )
RETURN p</pre><p>This means: find a single shortest path between two nodes, as long as the path is max 15 relationships long. Inside of the parenthesis
 you write a single link of a path — the starting node, the connecting relationship and the end node. Characteristics describing the relationship
 like relationship type, max hops and direction are all used when finding the shortest path. You can also mark the path as optional.</p><div class="queryresult table"><a id="id533788"></a><p class="title"><b>Result</b></p><div class="queryresult table-contents"><table summary="Result" cellspacing="0" cellpadding="0" border="1"><colgroup><col /></colgroup><thead><tr><th align="left" valign="top">p</th></tr></thead><tfoot><tr><th align="left" valign="top">1 row
</th></tr><tr><th align="left" valign="top">0 ms</th></tr></tfoot><tbody><tr><td align="left" valign="top"><p><code class="literal">[Node[1]{name:"David"},:KNOWS[2] {},Node[3]{name:"Anders"},:KNOWS[0] {},Node[4]{name:"Bossman"},:KNOWS[3] {},Node[2]{name:"Emil"}]</code></p></td></tr></tbody></table></div></div><br class="queryresult table-break" /></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="match-all-shortest-paths"></a>16.10.18. All shortest paths</h3></div></div></div><p>Finds all the shortest paths between two nodes.</p><p><span class="emphasis"><em>Query</em></span></p><pre class="programlisting brush: cypher">START d=node(1), e=node(2)
MATCH p = allShortestPaths( d-[*..15]-&gt;e )
RETURN p</pre><p>This will find the two directed paths between David and Emil.</p><div class="queryresult table"><a id="id533914"></a><p class="title"><b>Result</b></p><div class="queryresult table-contents"><table summary="Result" cellspacing="0" cellpadding="0" border="1"><colgroup><col /></colgroup><thead><tr><th align="left" valign="top">p</th></tr></thead><tfoot><tr><th align="left" valign="top">2 rows
</th></tr><tr><th align="left" valign="top">0 ms</th></tr></tfoot><tbody><tr><td align="left" valign="top"><p><code class="literal">[Node[1]{name:"David"},:KNOWS[2] {},Node[3]{name:"Anders"},:KNOWS[0] {},Node[4]{name:"Bossman"},:KNOWS[3] {},Node[2]{name:"Emil"}]</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">[Node[1]{name:"David"},:KNOWS[2] {},Node[3]{name:"Anders"},:BLOCKS[1] {},Node[5]{name:"Cesar"},:KNOWS[4] {},Node[2]{name:"Emil"}]</code></p></td></tr></tbody></table></div></div><br class="queryresult table-break" /></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="match-named-path"></a>16.10.19. Named path</h3></div></div></div><p>If you want to return or filter on a path in your pattern graph, you can a introduce a named path.</p><p><span class="emphasis"><em>Query</em></span></p><pre class="programlisting brush: cypher">START a=node(3)
MATCH p = a--&gt;b
RETURN p</pre><p>This returns the two paths starting from the first node.</p><div class="queryresult table"><a id="id534052"></a><p class="title"><b>Result</b></p><div class="queryresult table-contents"><table summary="Result" cellspacing="0" cellpadding="0" border="1"><colgroup><col /></colgroup><thead><tr><th align="left" valign="top">p</th></tr></thead><tfoot><tr><th align="left" valign="top">2 rows
</th></tr><tr><th align="left" valign="top">0 ms</th></tr></tfoot><tbody><tr><td align="left" valign="top"><p><code class="literal">[Node[3]{name:"Anders"},:KNOWS[0] {},Node[4]{name:"Bossman"}]</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">[Node[3]{name:"Anders"},:BLOCKS[1] {},Node[5]{name:"Cesar"}]</code></p></td></tr></tbody></table></div></div><br class="queryresult table-break" /></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="match-matching-on-a-bound-relationship"></a>16.10.20. Matching on a bound relationship</h3></div></div></div><p>When your pattern contains a bound relationship, and that relationship pattern doesn’t specify direction,
                Cypher will try to match the relationship where the connected nodes switch sides.</p><p><span class="emphasis"><em>Query</em></span></p><pre class="programlisting brush: cypher">START a=node(3), b=node(2)
MATCH a-[?:KNOWS]-x-[?:KNOWS]-b
RETURN x</pre><p>This returns the two connected nodes, once as the start node, and once as the end node</p><div class="queryresult table"><a id="id534193"></a><p class="title"><b>Result</b></p><div class="queryresult table-contents"><table summary="Result" cellspacing="0" cellpadding="0" border="1"><colgroup><col /></colgroup><thead><tr><th align="left" valign="top">x</th></tr></thead><tfoot><tr><th align="left" valign="top">3 rows
</th></tr><tr><th align="left" valign="top">0 ms</th></tr></tfoot><tbody><tr><td align="left" valign="top"><p><code class="literal">Node[4]{name:"Bossman"}</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">Node[5]{name:"Cesar"}</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">Node[1]{name:"David"}</code></p></td></tr></tbody></table></div></div><br class="queryresult table-break" /></div></div><HR xmlns=""></HR><a xmlns="" href="ln-id464096.html"><p xmlns="http://www.w3.org/1999/xhtml" class="copyright">Copyright © 2012 Neo Technology</p></a><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="query-start.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="cypher-query-lang.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="query-where.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top"> </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> </td></tr></table></div></body></html>
