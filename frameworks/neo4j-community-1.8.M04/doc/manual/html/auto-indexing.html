<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>15.12. Automatic Indexing</title><link rel="stylesheet" href="docbook-xsl.css" type="text/css" /><meta name="generator" content="DocBook XSL Stylesheets V1.75.2" /><link rel="home" href="index.html" title="The Neo4j Manual v1.8.M04" /><link rel="up" href="indexing.html" title="Chapter 15. Indexing" /><link rel="prev" href="indexing-lucene-extras.html" title="15.11. Extra features for Lucene indexes" /><link rel="next" href="cypher-query-lang.html" title="Chapter 16. Cypher Query Language" /><link rel="preface" href="preface.html" title="Preface" /><link rel="part" href="introduction.html" title="Part I. Introduction" /><link rel="chapter" href="introduction-highlights.html" title="Chapter 1. Neo4j Highlights" /><link rel="chapter" href="graphdb-concepts.html" title="Chapter 2. Graph Database Concepts" /><link rel="chapter" href="graphdb-neo4j.html" title="Chapter 3. The Neo4j Graph Database" /><link rel="part" href="tutorials.html" title="Part II. Tutorials" /><link rel="chapter" href="tutorials-java-embedded.html" title="Chapter 4. Using Neo4j embedded in Java applications" /><link rel="chapter" href="cypher-cookbook.html" title="Chapter 5. Cypher Cookbook" /><link rel="chapter" href="tutorials-rest.html" title="Chapter 6. Neo4j Remote Client Libraries" /><link rel="chapter" href="server-extending.html" title="Chapter 7. Extending the Neo4j Server" /><link rel="chapter" href="tutorial-traversal.html" title="Chapter 8. The Traversal Framework" /><link rel="chapter" href="domain-modeling-gallery.html" title="Chapter 9. Domain Modeling Gallery" /><link rel="chapter" href="languages.html" title="Chapter 10. Languages" /><link rel="chapter" href="tutorials-python-embedded.html" title="Chapter 11. Using Neo4j embedded in Python applications" /><link rel="part" href="reference-documentation.html" title="Part III. Reference" /><link rel="chapter" href="capabilities.html" title="Chapter 12. Capabilities" /><link rel="chapter" href="transactions.html" title="Chapter 13. Transaction Management" /><link rel="chapter" href="import.html" title="Chapter 14. Data Import" /><link rel="chapter" href="indexing.html" title="Chapter 15. Indexing" /><link rel="chapter" href="cypher-query-lang.html" title="Chapter 16. Cypher Query Language" /><link rel="chapter" href="graph-algo.html" title="Chapter 17. Graph Algorithms" /><link rel="chapter" href="server.html" title="Chapter 18. Neo4j Server" /><link rel="chapter" href="rest-api.html" title="Chapter 19. REST API" /><link rel="chapter" href="python-embedded.html" title="Chapter 20. Python embedded bindings" /><link rel="part" href="operations.html" title="Part IV. Operations" /><link rel="chapter" href="deployment.html" title="Chapter 21. Installation &amp; Deployment" /><link rel="chapter" href="embedded-configuration.html" title="Chapter 22. Configuration &amp; Performance" /><link rel="chapter" href="ha.html" title="Chapter 23. High Availability" /><link rel="chapter" href="operations-backup.html" title="Chapter 24. Backup" /><link rel="chapter" href="operations-security.html" title="Chapter 25. Security" /><link rel="chapter" href="operations-monitoring.html" title="Chapter 26. Monitoring" /><link rel="part" href="tools.html" title="Part V. Tools" /><link rel="chapter" href="tools-webadmin.html" title="Chapter 27. Web Administration" /><link rel="chapter" href="shell.html" title="Chapter 28. Neo4j Shell" /><link rel="part" href="community.html" title="Part VI. Community" /><link rel="chapter" href="community-support.html" title="Chapter 29. Community Support" /><link rel="chapter" href="community-contributing.html" title="Chapter 30. Contributing to Neo4j" /><link rel="appendix" href="manpages.html" title="Appendix A. Manpages" /><link rel="refentry" href="re01.html" title="neo4j" /><link rel="refentry" href="re02.html" title="neo4j-shell" /><link rel="refentry" href="re03.html" title="neo4j-backup" /><link rel="refentry" href="re04.html" title="neo4j-coordinator" /><link rel="refentry" href="re05.html" title="neo4j-coordinator-shell" /><link rel="appendix" href="questions.html" title="Appendix B. Questions &amp; Answers" /><link rel="subsection" href="auto-indexing.html#auto-indexing-config" title="15.12.1. Configuration" /><link rel="subsection" href="auto-indexing.html#auto-indexing-api" title="15.12.2. Search" /><link rel="subsection" href="auto-indexing.html#auto-indexing-config-api" title="15.12.3. Runtime Configuration" /><link rel="subsection" href="auto-indexing.html#auto-indexing-update-removal" title="15.12.4. Updating the Automatic Index" /><link rel="copyright" href="ln-id464096.html" title="License: Creative Commons 3.0" />


<!-- favicon -->

<link rel="shortcut icon" href="http://neo4j.org/favicon.ico" type="image/vnd.microsoft.icon" />
<link rel="icon" href="http://neo4j.org/favicon.ico" type="image/x-icon" />

<!-- style -->

<link href="css/shCore.css" rel="stylesheet" type="text/css" />
<link href="css/shCoreEclipse.css" rel="stylesheet" type="text/css" />
<link href="css/shThemeEclipse.css" rel="stylesheet" type="text/css" />
<link href="css/neo.css" rel="stylesheet" type="text/css" />

<!-- Syntax Highlighter -->

<script type="text/javascript" src="js/shCore.js"></script>
<script type="text/javascript" src="js/shBrushJava.js"></script>
<script type="text/javascript" src="js/shBrushJScript.js"></script>
<script type="text/javascript" src="js/shBrushBash.js"></script>
<script type="text/javascript" src="js/shBrushPlain.js"></script>
<script type="text/javascript" src="js/shBrushXml.js"></script>
<script type="text/javascript" src="js/shBrushGroovy.js"></script>
<script type="text/javascript" src="js/shBrushCypher.js"></script>
<script type="text/javascript" src="js/shBrushScala.js"></script>
<script type="text/javascript" src="js/shBrushSql.js"></script>
<script type="text/javascript" src="js/shBrushPython.js"></script>

<!-- activate when needed
<script type="text/javascript" src="js/shBrushRuby.js"></script>
<script type="text/javascript" src="js/shBrushCSharp.js"></script>
-->
 
<script type="text/javascript">
  SyntaxHighlighter.defaults['tab-size'] = 4;
  SyntaxHighlighter.defaults['gutter'] = false;
  SyntaxHighlighter.defaults['toolbar'] = false;
  SyntaxHighlighter.all()
</script>

<!-- JQuery -->

<script type="text/javascript" src="js/jquery-1.6.4.min.js"></script>

<!-- Replace SVG for browsers that lack support. -->
<script type="text/javascript" src="js/svgreplacer.js"></script>

<!-- Image Scaler -->

<script type="text/javascript" src="js/imagescaler.js"></script>

<!-- Table Styler -->

<script type="text/javascript" src="js/tablestyler.js"></script>

<!-- Version -->

<script type="text/javascript" src="js/version.js"></script>

<!-- Offline Sidebar -->

<script type="text/javascript" src="js/sidebar.js"></script>


<div xmlns="" class="breadcrumbs"><span class="breadcrumb-link"><a href="index.html">The Neo4j Manual</a></span> &gt; <span class="breadcrumb-link"><a href="reference-documentation.html">Reference</a></span> &gt; <span class="breadcrumb-link"><a href="indexing.html">Indexing</a></span> &gt; <span class="breadcrumb-node">Automatic Indexing</span></div></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><td width="20%" align="left"><a accesskey="p" href="indexing-lucene-extras.html">Prev</a> </td><th width="60%" align="center"> </th><td width="20%" align="right"> <a accesskey="n" href="cypher-query-lang.html">Next</a></td></tr></table><hr /></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="auto-indexing"></a>15.12. Automatic Indexing</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="auto-indexing.html#auto-indexing-config">15.12.1. Configuration</a></span></dt><dt><span class="section"><a href="auto-indexing.html#auto-indexing-api">15.12.2. Search</a></span></dt><dt><span class="section"><a href="auto-indexing.html#auto-indexing-config-api">15.12.3. Runtime Configuration</a></span></dt><dt><span class="section"><a href="auto-indexing.html#auto-indexing-update-removal">15.12.4. Updating the Automatic Index</a></span></dt></dl></div><p>Neo4j provides a single index for nodes and one for relationships in each database that automatically follow property values as they are added, deleted and changed on database primitives.
This functionality is called <span class="emphasis"><em>auto indexing</em></span> and is controlled both from the database configuration Map and through its own API.</p><div class="caution" style="margin-left: 0; margin-right: 10%;"><table border="0" summary="Caution"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Caution]" src="images/icons/admon/caution.png" /></td><th align="left">Caution</th></tr><tr><td align="left" valign="top"><p>This is an experimental feature. Expect changes in the API and do not rely on it for production data handling.</p></td></tr></table></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="auto-indexing-config"></a>15.12.1. Configuration</h3></div></div></div><p>By default Auto Indexing is off for both Nodes and Relationships.
To enable it on database startup set the configuration options <code class="literal">Config.NODE_AUTO_INDEXING</code>
and <code class="literal">Config.RELATIONSHIP_AUTO_INDEXING</code> to the string "<code class="literal">true</code>".</p><p>If you just enable auto indexing as above, then still <span class="emphasis"><em>no</em></span> property will be auto indexed. To define which property names
you want the auto indexer to monitor as a configuration parameter, set the <code class="literal">Config.{NODE,RELATIONSHIP}_KEYS_INDEXABLE</code>
option to a String that is a comma separated concatenation of the property names you want auto indexed.</p><pre class="programlisting brush: java">/*
 * Creating the configuration, adding nodeProp1 and nodeProp2 as
 * auto indexed properties for Nodes and relProp1 and relProp2 as
 * auto indexed properties for Relationships. Only those will be
 * indexed. We also have to enable auto indexing for both these
 * primitives explicitly.
 */
GraphDatabaseService graphDb = new GraphDatabaseFactory().
    newEmbeddedDatabaseBuilder( storeDirectory ).
    setConfig( GraphDatabaseSettings.node_keys_indexable, "nodeProp1,nodeProp2" ).
    setConfig( GraphDatabaseSettings.relationship_keys_indexable, "relProp1,relProp2" ).
    setConfig( GraphDatabaseSettings.node_auto_indexing, GraphDatabaseSetting.TRUE ).
    setConfig( GraphDatabaseSettings.relationship_auto_indexing, GraphDatabaseSetting.TRUE ).
    newGraphDatabase();

Transaction tx = graphDb.beginTx();
Node node1 = null, node2 = null;
Relationship rel = null;
try
{
    // Create the primitives
    node1 = graphDb.createNode();
    node2 = graphDb.createNode();
    rel = node1.createRelationshipTo( node2,
            DynamicRelationshipType.withName( "DYNAMIC" ) );

    // Add indexable and non-indexable properties
    node1.setProperty( "nodeProp1", "nodeProp1Value" );
    node2.setProperty( "nodeProp2", "nodeProp2Value" );
    node1.setProperty( "nonIndexed", "nodeProp2NonIndexedValue" );
    rel.setProperty( "relProp1", "relProp1Value" );
    rel.setProperty( "relPropNonIndexed", "relPropValueNonIndexed" );

    // Make things persistent
    tx.success();
}
catch ( Exception e )
{
    tx.failure();
}
finally
{
    tx.finish();
}
</pre></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="auto-indexing-api"></a>15.12.2. Search</h3></div></div></div><p>The usefulness of the auto indexing functionality comes of course from the ability to actually query the index and retrieve results.
To that end, you can acquire a <code class="literal">ReadableIndex</code> object from the <code class="literal">AutoIndexer</code> that exposes all the query and get methods of a full
<a class="ulink" href="http://components.neo4j.org/neo4j/1.8.M04/apidocs/org/neo4j/graphdb/index/Index.html" target="_top"><code class="literal">Index</code></a> with exactly the same functionality.
Continuing from the previous example, accessing the index is done like this:</p><pre class="programlisting brush: java">// Get the Node auto index
ReadableIndex&lt;Node&gt; autoNodeIndex = graphDb.index()
        .getNodeAutoIndexer()
        .getAutoIndex();
// node1 and node2 both had auto indexed properties, get them
assertEquals( node1,
        autoNodeIndex.get( "nodeProp1", "nodeProp1Value" ).getSingle() );
assertEquals( node2,
        autoNodeIndex.get( "nodeProp2", "nodeProp2Value" ).getSingle() );
// node2 also had a property that should be ignored.
assertFalse( autoNodeIndex.get( "nonIndexed",
        "nodeProp2NonIndexedValue" ).hasNext() );

// Get the relationship auto index
ReadableIndex&lt;Relationship&gt; autoRelIndex = graphDb.index()
        .getRelationshipAutoIndexer()
        .getAutoIndex();
// One property was set for auto indexing
assertEquals( rel,
        autoRelIndex.get( "relProp1", "relProp1Value" ).getSingle() );
// The rest should be ignored
assertFalse( autoRelIndex.get( "relPropNonIndexed",
        "relPropValueNonIndexed" ).hasNext() );
</pre></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="auto-indexing-config-api"></a>15.12.3. Runtime Configuration</h3></div></div></div><p>The same options that are available during database creation via the configuration can also be set during runtime via the <code class="literal">AutoIndexer</code> API.</p><p>Gaining access to the <code class="literal">AutoIndexer</code> API and adding two <code class="literal">Node</code> and one <code class="literal">Relationship</code> properties to auto index is done like so:</p><pre class="programlisting brush: java">// Start without any configuration
GraphDatabaseService graphDb = new GraphDatabaseFactory().
        newEmbeddedDatabase( storeDirectory );

// Get the Node AutoIndexer, set nodeProp1 and nodeProp2 as auto
// indexed.
AutoIndexer&lt;Node&gt; nodeAutoIndexer = graphDb.index()
        .getNodeAutoIndexer();
nodeAutoIndexer.startAutoIndexingProperty( "nodeProp1" );
nodeAutoIndexer.startAutoIndexingProperty( "nodeProp2" );

// Get the Relationship AutoIndexer
AutoIndexer&lt;Relationship&gt; relAutoIndexer = graphDb.index()
        .getRelationshipAutoIndexer();
relAutoIndexer.startAutoIndexingProperty( "relProp1" );

// None of the AutoIndexers are enabled so far. Do that now
nodeAutoIndexer.setEnabled( true );
relAutoIndexer.setEnabled( true );

</pre><p><a id="NOTE"></a>Parameters to the AutoIndexers passed through the Configuration and settings made through the API are cumulative.
So you can set some beforehand known settings, do runtime checks to augment the initial configuration and then enable the desired auto indexers -
the final configuration is the same regardless of the method used to reach it.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="auto-indexing-update-removal"></a>15.12.4. Updating the Automatic Index</h3></div></div></div><p>Updates to the auto indexed properties happen of course automatically as you update them. Removal of properties from the auto index happens for two reasons.
One is that you actually removed the property. The other is that you stopped autoindexing on a property. When the latter happens, any primitive you touch and
it has that property, it is removed from the auto index, regardless of any operations on the property.
When you start or stop auto indexing on a property, no auto update operation happens currently. If you need to change the set of auto indexed properties and
have them re-indexed, you currently have to do this by hand. An example will illustrate the above better:</p><pre class="programlisting brush: java">/*
 * Creating the configuration
 */
GraphDatabaseService graphDb = new GraphDatabaseFactory().
    newEmbeddedDatabaseBuilder( storeDirectory ).
    setConfig( GraphDatabaseSettings.node_keys_indexable, "nodeProp1,nodeProp2" ).
    setConfig( GraphDatabaseSettings.node_auto_indexing, GraphDatabaseSetting.TRUE ).
    newGraphDatabase();

Transaction tx = graphDb.beginTx();
Node node1 = null, node2 = null, node3 = null, node4 = null;
try
{
    // Create the primitives
    node1 = graphDb.createNode();
    node2 = graphDb.createNode();
    node3 = graphDb.createNode();
    node4 = graphDb.createNode();

    // Add indexable and non-indexable properties
    node1.setProperty( "nodeProp1", "nodeProp1Value" );
    node2.setProperty( "nodeProp2", "nodeProp2Value" );
    node3.setProperty( "nodeProp1", "nodeProp3Value" );
    node4.setProperty( "nodeProp2", "nodeProp4Value" );

    // Make things persistent
    tx.success();
}
catch ( Exception e )
{
    tx.failure();
}
finally
{
    tx.finish();
}

/*
 *  Here both nodes are indexed. To demonstrate removal, we stop
 *  autoindexing nodeProp1.
 */
AutoIndexer&lt;Node&gt; nodeAutoIndexer = graphDb.index().getNodeAutoIndexer();
nodeAutoIndexer.stopAutoIndexingProperty( "nodeProp1" );

tx = graphDb.beginTx();
try
{
    /*
     * nodeProp1 is no longer auto indexed. It will be
     * removed regardless. Note that node3 will remain.
     */
    node1.setProperty( "nodeProp1", "nodeProp1Value2" );
    /*
     * node2 will be auto updated
     */
    node2.setProperty( "nodeProp2", "nodeProp2Value2" );
    /*
     * remove node4 property nodeProp2 from index.
     */
    node4.removeProperty( "nodeProp2" );
    // Make things persistent
    tx.success();
}
catch ( Exception e )
{
    tx.failure();
}
finally
{
    tx.finish();
}

// Verify
ReadableIndex&lt;Node&gt; nodeAutoIndex = nodeAutoIndexer.getAutoIndex();
// node1 is completely gone
assertFalse( nodeAutoIndex.get( "nodeProp1", "nodeProp1Value" ).hasNext() );
assertFalse( nodeAutoIndex.get( "nodeProp1", "nodeProp1Value2" ).hasNext() );
// node2 is updated
assertFalse( nodeAutoIndex.get( "nodeProp2", "nodeProp2Value" ).hasNext() );
assertEquals( node2,
        nodeAutoIndex.get( "nodeProp2", "nodeProp2Value2" ).getSingle() );
/*
 * node3 is still there, despite its nodeProp1 property not being monitored
 * any more because it was not touched, in contrast with node1.
 */
assertEquals( node3,
        nodeAutoIndex.get( "nodeProp1", "nodeProp3Value" ).getSingle() );
// Finally, node4 is removed because the property was removed.
assertFalse( nodeAutoIndex.get( "nodeProp2", "nodeProp4Value" ).hasNext() );
</pre><div class="caution" style="margin-left: 0; margin-right: 10%;"><table border="0" summary="Caution"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Caution]" src="images/icons/admon/caution.png" /></td><th align="left">Caution</th></tr><tr><td align="left" valign="top"><p>If you start the database with auto indexing enabled but different auto indexed properties than the last run, then already auto-indexed entities will be deleted
as you work with them. Make sure that the monitored set is what you want before enabling the functionality.</p></td></tr></table></div></div></div><HR xmlns=""></HR><a xmlns="" href="ln-id464096.html"><p xmlns="http://www.w3.org/1999/xhtml" class="copyright">Copyright © 2012 Neo Technology</p></a><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="indexing-lucene-extras.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="indexing.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="cypher-query-lang.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top"> </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> </td></tr></table></div></body></html>
